#!/bin/sh
# Copyright 2015 The Kubernetes Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

usage() {
    cat 1>&2 <<EOF

Invalid usage. Usage: 
    $DRIVER init
    $DRIVER waitforattach <json params>
    $DRIVER mountdevice <mount dir> <mount device> <json params>
    $DRIVER unmountdevice <mount dir>

EOF
    exit 1
}

err() {
    printf "$*" 1>&2
}

log() {
    printf "$*" >&1
}

getdevice() {
    # Find and connect new nbd device
    if [ -z "${DEVICE}" ]; then
        local NBDNUMBERS="$(ls -1 /dev/nbd[0-9]* | grep -o [0-9]* | sort -h)"
        for i in $NBDNUMBERS; do
            if ! lsblk "/dev/nbd$i" 1>/dev/null 2>/dev/null && ! ps x | grep -q "\[jbd2/nbd$i-8\]" && mkfifo /run/lock/qemu-nbd-nbd$i 2> /dev/null; then
                local NBDDEVICE="/dev/nbd$i"
                break
            fi
        done
    fi
    echo "$DEVICE"
}

dofilesystem() {
    [ "$FSTYPE" = "" ] && FSTYPE="ext4"
    [ "$MMP_INTERVAL" = null ] && MMP_INTERVAL=5 
    [ "$FSCK_OPTIONS" = null ] && FSCK_OPTIONS="a"

    # Calculate multimount protection options
    case "$MMP" in false|no|0)
        if [ "${FSTYPE}" = "ext4" ]; then
            MMP_OPT="-O mmp -E mmp_update_interval=${MMP_INTERVAL}"
        fi
    ;; esac

    VOLFSTYPE=`blkid -o udev "$1" 2>/dev/null|grep "ID_FS_TYPE"|cut -d"=" -f2`
    if [ "${VOLFSTYPE}" = "" ]; then
        # Make filesystem
        mkfs -t "${FSTYPE}" ${MMP_OPT} "${1}" >/dev/null 2>&1
        if [ $? -ne 0 ]; then
            err "{ \"status\": \"Failure\", \"message\": \"Failed to create fs ${FSTYPE} on device ${1}\"}"
            exit 1
        fi
    else
        # Do filesystem check
        case "$FSCK" in false|no|0)
            fsck -${FSCK_OPTIONS} ${1} 1>/dev/null 2>/dev/null
            if [ $? -ne 0 ]; then
                err "{ \"status\": \"Failure\", \"message\": \"Fsck -${FSCK_OPTIONS} check for ${1} was failed\"}"
                exit 1
            fi
        ;; esac
    fi
} 


attach() {
    log "{\"status\": \"Success\"}"
    exit 0
}

detach() {
    log "{\"status\": \"Success\"}"
    exit 0
}

waitforattach() {
    FSTYPE=$(echo "$1" | jq -r '.["kubernetes.io/fsType"]')
    MMP=$(echo "$1" | jq -r '.mmp')
    SIZE=$(echo "$1" | jq -r '.size' | tr '[:lower:]' '[:upper:]')
    FSCK=$(echo "$1" | jq -r '.fsck')
    MMP_INTERVAL=$(echo "$1" | jq -r '.mmpUpdateInterval')
    FSCK_OPTIONS=$(echo "$1" | jq -r '.fsckOptions')
    ALLOCATE=$(echo "$1" | jq -r '.allocate')

    # Get driver specific options
    if [ "$DRIVER" = "sheepdog" ] || [ "$DRIVER" = "sheepdog-iscsi" ]; then
        for OPTION in prealloc hyper copies address address port block_size_shift; do
            VALUE="$(echo "$1" | jq -r ".$OPTION")"
            export "$(echo $OPTION | tr '[:lower:]' '[:upper:]')=$VALUE"
            if [ "$VALUE" != "null" ]; then
                export DOG_CREATE_OPTS="$DOG_CREATE_OPTS --${OPTION}=${VALUE}"
            fi
        done
        VDINAME=$(echo $1 | jq -r '.vdiname')
    else
        SHARE=$(echo "$1" | jq -r '.share')
        FILE=$(echo "$1" | jq -r '.file')
        if [ "${SHARE}" != "null" ]; then
            FILE="${SHARE}/${FILE}"
        fi
    fi

    if [ "$DRIVER" != "sheepdog" ] && [ "$DRIVER" != "sheepdog-iscsi" ]; then
        IMAGE_URL="$FILE"
    elif [ "$DRIVER" = "sheepdog-iscsi" ]; then
        [ "$ADDRESS" != null ] || ADDRESS=127.0.0.1
        [ "$PORT" != null ] || PORT=7000
        IMAGE_URL="tcp:${ADDRESS}:${PORT}:${VDINAME}"
    elif [ "$ADDRESS" != null ] && [ "$PORT" = null ]; then
        IMAGE_URL="sheepdog://${ADDRESS}/${VDINAME}"
    elif [ "$ADDRESS" != null ] && [ "$PORT" != null ]; then
        IMAGE_URL="sheepdog://${ADDRESS}:${PORT}/${VDINAME}"
    elif [ "$ADDRESS" = null ] && [ "$PORT" != null ]; then
        IMAGE_URL="sheepdog://:${PORT}/${VDINAME}"
    else
        IMAGE_URL="sheepdog:${VDINAME}"
    fi

    # Check is SHARE mountpoint
    if [ "$DRIVER" != "sheepdog" ] && [ "$DRIVER" != "sheepdog-iscsi" ] && [ "${SHARE}" != "null" ]; then
        if ! mountpoint -q "${SHARE}"; then
            err "{ \"status\": \"Failed\", \"message\": \"${SHARE} is not mounted\"}"
            exit 0
        fi
    fi

    if [ "$DRIVER" = "qemu-nbd" ] || [ "$DRIVER" = "nbd" ]; then
        BINARIES="qemu-nbd"
    elif [ "$DRIVER" = "sheepdog" ]; then
        BINARIES="dog qemu-nbd"
    elif [ "$DRIVER" = "sheepdog-iscsi" ]; then
        BINARIES="dog iscsiadm tgtadm"
    fi
    
    # Check for qemu binaries
    for binary in $BINARIES; do
        if ! command -v $binary >/dev/null 2>&1; then
            err "{ \"status\": \"Failure\", \"message\": \"'$binary' binary not found.\"}"
            exit 1
        fi
    done

    # Check is image exist
    if [ "$DRIVER" != "sheepdog" ] && [ "$DRIVER" != "sheepdog-iscsi" ]; then
        if [ -f "${FILE}" ]; then
            IMAGE_EXIST=1
        else
            IMAGE_EXIST=0
        fi
    else
        if dog vdi list "$VDINAME" 2>/dev/null | tail -n +2 | grep -q .; then
            IMAGE_EXIST=1
        else
            IMAGE_EXIST=0
        fi
    fi

    # Allocate image
    if [ "$IMAGE_EXIST" = 0 ]; then
        if [ -z "${SIZE}" ]; then
            err "{\"status\": \"Failure\", \"message\": \"${IMAGE_URL} does not exist\"}"
            exit 1
        fi

        if [ "$DRIVER" != "sheepdog" ] && [ "$DRIVER" != "sheepdog-iscsi" ]; then
            mkdir -p "$(dirname "${FILE}")"
            truncate -s ${SIZE} "${FILE}" 2>/dev/null
            if [ $? -ne 0 ]; then
                err "{\"status\": \"Failure\", \"message\": \"Can not create file ${FILE}\"}"
                exit 1
            fi
        else
            dog vdi create $DOG_CREATE_OPTS "$VDINAME" "$SIZE"
            if [ $? -ne 0 ]; then
                err "{ \"status\": \"Failure\", \"message\": \"Failed to create vdi ${IMAGE_URL}\"}"
                exit 1
            fi
        fi
    fi

    # Do filesystem check
    if [ "$DRIVER" != "sheepdog" ] && [ "$DRIVER" != "sheepdog-iscsi" ]; then
        dofilesystem "$FILE"
    fi

    # Skip device setting when loop
    if [ "$DRIVER" = "loop" ]; then
        log "{\"status\": \"Success\", \"device\":\"${FILE}\"}"
        exit 0
    fi

    if [ "$DRIVER" != "sheepdog-iscsi" ]; then
        # Load nbd module
        modprobe nbd 2> /dev/null
        if [ $? -ne 0 ]; then
            err "{ \"status\": \"Failure\", \"message\": \"Failed to load nbd module\"}"
            exit 1
        fi

        # Check is already attached
        DEVICE="$(ps aux | sed -n "s|.*qemu-nbd -t -f raw -c \(/dev/nbd[0-9]\+\) ${IMAGE_URL}\$|\1|p" | head -n1)"
        if [ ! -z "${DEVICE}" ]; then
            log "{\"status\": \"Success\", \"device\":\"${DEVICE}\"}"
            exit 0
        fi

        # Get free nbd device
        DEVICE="$(getdevice)"
        if [ -z "${DEVICE}" ]; then
            err "{\"status\": \"Failure\", \"message\": \"Free nbd device was not found\"}"
            exit 1
        fi

        # Setup nbd device
        qemu-nbd -t -f raw -c "${DEVICE}" "${IMAGE_URL}" 1>/dev/null 2>/dev/null
        if [ $? -ne 0 ]; then
            err "{ \"status\": \"Failure\", \"message\": \"Failed to setup nbd device "${DEVICE}" from ${FILE}\"}"
            exit 1
        fi
    else
        # Setup target
        #TODO: check target id and configure target name
        ! tgtadm --op new --mode target --tid 1 --lld iscsi --targetname iqn.2013-10.org.sheepdog-project 2>&1 | grep -qv "this target already exists"
        if [ $? -ne 0 ]; then
            err "{ \"status\": \"Failure\", \"message\": \"Failed to setup nbd device "${DEVICE}" from ${FILE}\"}"
            exit 1
        fi

        # Setup LUN
        #TODO: take only needed target
        LUN=$(tgtadm --lld iscsi --mode target --op show 2> /dev/null | grep "Backing store path: ${IMAGE_URL}$" -B 12 -A 1 | sed -n 's/.*LUN: \([0-9]\+\).*/\1/p')
        if [ -z "$LUN" ]; then
            LAST_LUN=$(tgtadm --lld iscsi --mode target --op show 2>/dev/null | sed -n 's/LUN: \([0-9]\+\)/\1/p' | sort -h)
            LUN=$((LAST_LUN+1))
            tgtadm --op new --mode lu --tid 1 --lun $LUN --bstype sheepdog --backing-store "${IMAGE_URL}" 1>/dev/null 2>/dev/null
            if [ $? -ne 0 ]; then
                err "{ \"status\": \"Failure\", \"message\": \"Failed to attach LUN $LUN from ${IMAGE_URL}\"}"
                exit 1
            fi
            tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL 1>/dev/null 2>/dev/null
        fi

        # Setup session
        SESSION_ID=$(iscsiadm -m session 2> /dev/null | sed -n 's/^tcp: \[\([0-9]\+\)\].* iqn.2013-10.org.sheepdog-project .*/\1/p')
        if [ -z "$SESSION_ID" ]; then
            iscsiadm -m discovery -t st -p 127.0.0.1
            iscsiadm -m node --targetname iqn.2013-10.org.sheepdog-project --portal 127.0.0.1:3260 --login 1>/dev/null 2>/dev/null
            if [ $? -ne 0 ]; then
                err "{ \"status\": \"Failure\", \"message\": \"Failed to setup iSCSI session\"}"
                exit 1
            fi
        else
            iscsiadm -m session --sid="$SESSION_ID" --rescan 1>/dev/null 2>/dev/null
        fi

        #TODO: handle LUNs >255
        DEVICE=$(readlink /dev/disk/by-path/ip-127.0.0.1\:3260-iscsi-iqn.2013-10.org.sheepdog-project-lun-${LUN} | awk -F/ '{print "/dev/" $NF}')
        if [ -z "${DEVICE}" ]; then
            err "{\"status\": \"Failure\", \"message\": \"iSCSI device was not found\"}"
            exit 1
        fi

    fi

    # Do filesystem check
    if [ "$DRIVER" = "sheepdog" ] || [ "$DRIVER" = "sheepdog-iscsi" ]; then
        dofilesystem "$DEVICE"
    fi

    log "{\"status\": \"Success\", \"device\":\"${DEVICE}\"}"
    exit 0
}

mountdevice() {
    MNTPATH=$1
    DEVICE=$2
    MOUNT_OPTIONS=$(echo $3 | jq -r '.mount_options')
    [ "$MOUNT_OPTIONS" = null ] && MOUNT_OPTIONS=""
    if [ "$DRIVER" = "loop" ]; then
        MOUNT_OPTIONS="loop,$MOUNTOPTIONS"
    fi

    # Create mountpoint
    mkdir -p "${MNTPATH}" 1>/dev/null 2>/dev/null

    # Check is already mounted
    if mountpoint -q "${MNTPATH}"; then
        log "{\"status\": \"Success\"}"
        exit 0
    fi

    # Mount device
    mount -o "${MOUNT_OPTIONS}" "${DEVICE}" "${MNTPATH}" 1>/dev/null 2>/dev/null
    if [ $? -ne 0 ]; then
        err "{ \"status\": \"Failure\", \"message\": \"Failed to mount device ${DEVICE} at ${MNTPATH}\"}"
        exit 1
    fi

    log "{\"status\": \"Success\"}"
    exit 0
}


unmountdevice() {
    MNTPATH=$1
    DEVICE=$(mount | awk "\$3 == \"$(readlink -f $MNTPATH)\" {print \$1}" | head -n 1)

    if [ ! -d ${MNTPATH} ]; then
        log "{\"status\": \"Success\"}"
        exit 0
    fi

    if ! mountpoint -q "${MNTPATH}"; then
        log "{\"status\": \"Success\"}"
        exit 0
    fi

    umount ${MNTPATH} 1>/dev/null 2>/dev/null
    if [ $? -ne 0 ]; then
        err "{ \"status\": \"Failed\", \"message\": \"Failed to unmount volume at ${MNTPATH}\"}"
        exit 1
    fi

    if [ "$DRIVER" != "loop" ] && [ "$DRIVER" != "sheepdog-iscsi" ]; then
        sleep 1
        qemu-nbd -d ${DEVICE} 1>/dev/null 2>/dev/null
        if [ $? -ne 0 ]; then
            err "{ \"status\": \"Failure\", \"message\": \"Failed to detach device ${DEVICE}\"}"
            exit 1
        fi
    elif [ "$DRIVER" = "sheepdog-iscsi" ]; then

        #TODO: handle LUNs >255
        LUN=$(ls -l /dev/disk/by-path | sed -n "s/.*lun-\([0-9]\)\+ -> \.\.\/\.\.\/${DEVICE##*/}$/\1/p")
        tgtadm --op delete --mode lu --tid 1 --lun $LUN 1>/dev/null 2>/dev/null
        if [ $? -ne 0 ]; then
            err "{ \"status\": \"Failure\", \"message\": \"Failed to detach LUN $LUN\"}"
            exit 1
        fi

        # Reload session
        SESSION_ID=$(iscsiadm -m session 2> /dev/null | sed -n 's/^tcp: \[\([0-9]\+\)\].* iqn.2013-10.org.sheepdog-project .*/\1/p')
        iscsiadm -m session --sid="$SESSION_ID" --rescan 1>/dev/null 2>/dev/null

    fi

    log "{\"status\": \"Success\"}"
    exit 0
}


PATH="$PATH:$(dirname "$(readlink -f "$0")")"
DRIVER="$(basename $0)"
OPERATION=$1

# enable debug
echo "$DRIVER $@" >> /tmp/flex-qemu-nbd.log

case "${DRIVER}" in
    loop|qemu-nbd|nbd|sheepdog|sheepdog-iscsi)
        true
        ;;
    *)
        err "{ \"status\": \"Failure\", \"message\": \"'${DRIVER}' wrong name for driver\"}"
        exit 1
        ;;
esac

if ! command -v jq >/dev/null 2>&1; then
    err "{ \"status\": \"Failure\", \"message\": \"'jq' binary not found. Please install jq package before using this driver\"}"
    exit 1
fi

if [ "$OPERATION" = "init" ]; then
    # Disable kernel panic on oops due:
    # http://lkml.iu.edu/hypermail/linux/kernel/1509.2/04313.html
    (echo 0 > /proc/sys/kernel/panic_on_oops) 2>/dev/null || true

    log "{\"status\":\"Success\",\"capabilities\":{\"attach\":true}}"
    exit 0
fi

if [ $# -lt 2 ]; then
    usage
fi

shift

case "$OPERATION" in
    attach)
        attach $*
        ;;
    detach)
        detach $*
        ;;
    waitforattach)
        waitforattach $*
        ;;
    mountdevice)
        mountdevice $*
        ;;
    unmountdevice)
        unmountdevice $*
        ;;
    *)
        log "{ \"status\": \"Not supported\" }"
        exit 0
    ;;
esac

exit 1
