#!/bin/bash

# Copyright 2015 The Kubernetes Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Notes:
#  - Please install "jq" package before using this driver.

usage() {
    err "Invalid usage. Usage: "
    err "\t$0 init"
    err "\t$0 mountdevice <mount dir> <mount device> <json params>"
    err "\t$0 unmountdevice <mount dir>"
    exit 1
}

err() {
    echo -ne $* 1>&2
}

log() {
    echo -ne $* >&1
}

domount() {
    MNTPATH=$1

    for OPTION in prealloc hyper copies address port block_size_shift; do
        VALUE="$(echo "$2" | jq -r ".$OPTION")"
        export "$(echo $OPTION | tr '[:lower:]' '[:upper:]')=$VALUE"
        if [ "$VALUE" != "null" ]; then
            export DOG_CREATE_OPTS+=" --${OPTION}=${VALUE}"
        fi
    done

    VDINAME=$(echo $2 | jq -r '.vdiname')
    SIZE=$(echo $2 | jq -r '.size' | tr '[:lower:]' '[:upper:]')
    FSTYPE=$(echo $2 | jq -r '.["kubernetes.io/fsType"]')
    MMP=$(echo $2 | jq -r '.mmp')
    FSCK=$(echo $2 | jq -r '.fsck')
    MMP_INTERVAL=$(echo $3 | jq -r '.mmpUpdateInterval')
    FSCK_OPTIONS=$(echo $2 | jq -r '.fsck_options')
    MOUNT_OPTIONS=$(echo $2 | jq -r '.mount_options')

    case null in
        ${MMP_INTERVAL} ) MMP_INTERVAL=5  ;&
        ${FSCK_OPTIONS}  ) FSCK_OPTIONS="a" ;&
        ${MOUNT_OPTIONS} ) MOUNT_OPTIONS="" ;;
    esac

    if [ "$ADDRESS" != null ] && [ "$PORT" == null ]; then
        IMAGE_URL="sheepdog://${ADDRESS}/${VDINAME}"
    elif [ "$ADDRESS" != null ] && [ "$PORT" != null ]; then
        IMAGE_URL="sheepdog://${ADDRESS}:${PORT}/${VDINAME}"
    elif [ "$ADDRESS" == null ] && [ "$PORT" != null ]; then
        IMAGE_URL="sheepdog://:${PORT}/${VDINAME}"
    else
        IMAGE_URL="sheepdog:${VDINAME}"
    fi

    if [[ "${MMP}" != +(false|no|0) ]] && [ "${FSTYPE}" == "ext4" ]; then
        MMP_OPT="-O mmp -E mmp_update_interval=${MMP_INTERVAL}"
    fi

    QEMU_IMG_INFO_STDERR="$(qemu-img info "${IMAGE_URL}" 2>&1 1>/dev/null)"

    if echo "$QEMU_IMG_INFO_STDERR" | grep -q 'No vdi found'; then
        if [ -z "${SIZE}" ]; then
            err "{\"status\": \"Failure\", \"message\": \"Failed to get ${IMAGE_URL}.\"}"
            exit 1
        else
            dog vdi create $DOG_CREATE_OPTS "$VDINAME" "$SIZE"
            if [ $? -ne 0 ]; then
                err "{ \"status\": \"Failure\", \"message\": \"Failed to create vdi ${IMAGE_URL}\"}"
                exit 1
            fi
        fi
    elif [ -n "$QEMU_IMG_INFO_STDERR" ]; then
        err "{ \"status\": \"Failure\", \"message\": \"${QEMU_IMG_INFO_STDERR}\"}"
        exit 1
    fi

    if mountpoint -q "${MNTPATH}"; then
        log "{\"status\": \"Success\"}"
        exit 0
    fi

    modprobe nbd 2> /dev/null
    if [ $? -ne 0 ]; then
        err "{ \"status\": \"Failure\", \"message\": \"Failed to load nbd module\"}"
        exit 1
    fi

    # Check if nbd device already connected
    NBDDEVICE="$(ps aux | sed -n "s|.*qemu-nbd -f raw -c \(/dev/nbd[0-9]\+\) ${IMAGE_URL}\$|\1|p" | head -n1)"

    # Find and connect new nbd device
    if [ -z "${NBDDEVICE}" ]; then
        NBDNUMBERS="$(ls -1 /dev/nbd[0-9]* | grep -o [0-9]* | sort -h)"
        for i in $NBDNUMBERS; do
            if fdisk -l "/dev/nbd$i" 2>&1 | grep -q 'Inappropriate ioctl for device' && mkfifo /run/lock/qemu-nbd-nbd$i 2> /dev/null; then
                NBDDEVICE="/dev/nbd$i"
                break
            fi
        done

        if [ -z "${NBDDEVICE}" ]; then
            err "{\"status\": \"Failure\", \"message\": \"Free nbd device was not found\"}"
            exit 1
        fi
    
        qemu-nbd -f raw -c "${NBDDEVICE}" "${IMAGE_URL}" &>/dev/null
    
        if [ $? -ne 0 ]; then
            err "{ \"status\": \"Failure\", \"message\": \"Failed to setup nbd device "${NBDDEVICE}" from ${IMAGE_URL}\"}"
            exit 1
        fi
    fi


    VOLFSTYPE=`blkid -o udev ${NBDDEVICE} 2>/dev/null|grep "ID_FS_TYPE"|cut -d"=" -f2`
    if [ "${VOLFSTYPE}" == "" ]; then

        mkfs -t ${FSTYPE} ${MMP_OPT} ${NBDDEVICE} >/dev/null 2>&1
        if [ $? -ne 0 ]; then
            err "{ \"status\": \"Failure\", \"message\": \"Failed to create fs ${FSTYPE} on device ${NBDDEVICE}\"}"
            exit 1
        fi
    fi

    if [[ "${FSCK}" != +(false|no|0) ]]; then
        FSCK_STDERR="$(fsck -${FSCK_OPTIONS} -t ${FSTYPE} ${NBDDEVICE} 2>&1 1>/dev/null)"
        if [ $? -ne 0 ]; then
            err "{ \"status\": \"Failure\", \"message\": \"Fsck -${FSCK_OPTIONS} was failed: ${FSCK_STDERR}\"}"
            exit 1
        fi
    fi

    mkdir -p "${MNTPATH}" &> /dev/null



    mount -o "${MOUNT_OPTIONS}" "${NBDDEVICE}" "${MNTPATH}" &> /dev/null
    if [ $? -ne 0 ]; then
        err "{ \"status\": \"Failure\", \"message\": \"Failed to mount device ${NBDDEVICE} at ${MNTPATH}\"}"
        qemu-nbd -d "${NBDDEVICE}" &>/dev/null
        exit 1
    fi

    log "{\"status\": \"Success\"}"
    exit 0
}

unmount() {
    MNTPATH=$1
    NBDDEVICE=$(mount | awk "\$3 == \"$(readlink -f $MNTPATH)\" {print \$1}" | head -n 1)

    if [ -d ${MNTPATH} ] && mountpoint -q "${MNTPATH}"; then
        umount ${MNTPATH} &> /dev/null
        if [ $? -ne 0 ]; then
            err "{ \"status\": \"Failed\", \"message\": \"Failed to unmount volume at ${MNTPATH}\"}"
            exit 1
        fi
    fi

    if [ ! -z ${NBDDEVICE} ]; then
        sync
        qemu-nbd -d ${NBDDEVICE} &>/dev/null
    fi

    log "{\"status\": \"Success\"}"

    exit 0
}

op=$1

if ! command -v dog >/dev/null 2>&1; then
    err "{ \"status\": \"Failure\", \"message\": \"'dog' binary not found. Please install sheepdog package before using this driver\"}"
    exit 1
fi
if ! command -v jq >/dev/null 2>&1; then
    err "{ \"status\": \"Failure\", \"message\": \"'jq' binary not found. Please install jq package before using this driver\"}"
    exit 1
fi

if [ "$op" = "init" ]; then
    log '{"status": "Success", "capabilities": {"attach": false}}'
    exit 0
fi

if [ $# -lt 2 ]; then
    usage
fi

shift

case "$op" in
    mount)
        domount $*
        ;;
    unmount)
        unmount $*
        ;;
    *)
        log "{ \"status\": \"Not supported\" }"
        exit 0
esac

exit 1
